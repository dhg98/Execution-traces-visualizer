/*
    Function that finds the first (leftmost) invisible or collapsed leaf (visible)
*/
function findFirstNotVisibleLeaf(node) {
    if (node.cut && !node.faded) return null;

    // Leaf
    if (!node._children) {
        if (!node.visible || (node.visible && node.collapsed)) return node;
        else return null;
    }
    // Internal
    for (let i = 0; i < node._children.length; ++i) {
        let ch = findFirstNotVisibleLeaf(node._children[i]);
        // If there is any, we return it. If not, we continue with the loop
        if (ch != null) return ch;
    }
    // There is not any coincidence in this subtree
    return null;
}

/* 
    Function that finds last visible leaf in the tree (if there is any)
*/
function findLastVisibleLeaf(node) {
    if (node.cut && !node.faded) return null;

    // Leaf
    if (!node._children) {
        if (node.visible) return node;
        else return null;
    }
    // Internal node
    for (let i = node._children.length - 1; i >= 0; --i) {
        let ch = findLastVisibleLeaf(node._children[i]);
        // If this path gives us a node, that is the leaf we are interested in
        if (ch) return ch;
        // Otherwise, continue looking
    }
    // If we have reached the end, we don't have visible leaves in the subtree 
    // generated by the given node
    return null;
}

/* 
    Function that finds the first non collapsed path to a leaf in the tree
    (if there is any)
*/
function findFirstNonCollapsedPathToLeaf(node) {
    if (node.cut) return null;

    // Leaf
    if (!node._children) {
        if (!node.collapsed && node.visible) // Non-collapsed and visible
            return node;
        else return null;
    }

    // Internal node
    for (let i = 0; i < node._children.length; ++i) {
        let ch = findFirstNonCollapsedPathToLeaf(node._children[i]);
        // If this path gives us a node, that is the leaf we are interested in
        if (ch) return ch;
        // Otherwise, continue looking
    }
    // If we have reached the end, we don't have non collapsed leaves in the 
    // subtree generated by the given node
    return null;
}

/*
    Function that finds the first visible ancestor
*/
function findVisibleAncestor(node, limit) {
    let parent = node.parent;
    if (!parent) return node; // There is no parent (we have reached the root)
    if (node === limit) return limit; // If we have reached the limit, we stop

    if (node.visible) return node;

    // If node is not visible, we go up in the path
    return findVisibleAncestor(parent, limit);
}

/* 
    Function that finds the limit of the collapsed path, starting at the founded
    leaf. That is, the first node in the path from the leaf to the root that
    shouldn't be collapsed
*/
function findFirstBifurcation(node, limit) {
    let parent = node.parent;
    if (!parent) return node; // There is no parent (we have reached the root)
    if (node === limit) return limit; // If we have reached the limit, we stop

    let index = parent._children.indexOf(node);
    for (let i = 0; i < parent._children.length; ++i) {
        // If children is visible and (is internal node or is a not-collapsed
        // leaf, parent is the ancestor we are looking for
        if ((i != index && parent._children[i].visible &&
                parent._children[i]._children) ||
            (i != index && parent._children[i].visible &&
                !parent._children[i]._children &&
                !parent._children[i].collapsed)) return parent;
    }

    // It is also possible that the parent has collapsed children. These
    // children (leaves), won't be at _children array
    if (parent.children) {
        index = parent.children.indexOf(node);
        for (let i = 0; i < parent.children.length; ++i) {
            if (i != index && !parent.children[i]._children &&
                parent.children[i].collapsed)
                return parent;
        }
    }
    // If we haven't found a node at this point, the ancestor can be hidden
    return findFirstBifurcation(parent, limit);
}

/*
    Function that expands the path between leaf and ancestor. Receives boolean
    to know if the index should be taken into account in order to add the real
    children in the correct position
*/
function expandPath(node, ancestor, collapsed, index = null) {
    if (node === ancestor) return;
    let parent = node.parent;
    parent.children = parent.children || [];
    if (!parent.children.includes(node)) {
        // Special case: index should be taken into account to add the real
        // children in the correct position
        if (collapsed && parent === ancestor)
            parent.children[index] = node;
        else {
            // If we are expanding this path, children and _children array are
            // the same from 0 to index - 1
            let index = parent._children.indexOf(node); // Not -1
            node.parent.children.splice(index, 0, node);
        }
    }
    node.visible = true;

    expandPath(node.parent, ancestor, collapsed, index);
}

/* 
    Function that starts from a given node and makes invisible the link of this
    node with its parent and continues up until limit is reached
*/
function makeInvisible(node, limit) {
    if (!node.parent || node === limit) return; // Root or reached limit
    else {
        // Node is inside the parent children list. To make it invisible, we 
        // need to remove it from the list
        let index = node.parent.children.indexOf(node);
        node.parent.children.splice(index, 1);
        if (node.parent.children.length == 0) node.parent.children = null
        node.visible = false;

        makeInvisible(node.parent, limit);
        if (node.collapsed) {
            node.collapsed = false;
            node.depth = node.realDepth;
            node.parent = node.realParent;
        }
    }
}

/*
    Function that collapses the path from the leaf to the ancestor to keep only
    the (new) connection between the leaf and the ancestor
*/
function collapseLeafPath(node, leaf, ancestor) {
    // Each node in the path will be invisible (except from leaf and ancestor)
    node.visible = false;
    // If we have reached the node that is the previous ancestor of ancestor of
    // the leaf, we need to update the connections
    if (node.parent === ancestor) {
        if (node.parent.children) {
            let index = node.parent.children.indexOf(node);
            if (index != -1) node.parent.children[index] = leaf;
            else node.parent.children.push(leaf);
        } else node.parent.children = [leaf];
        // Update leaf attributes so that it is printed correctly
        leaf.parent = ancestor;
        leaf.depth = ancestor.depth + 1;
        leaf.collapsed = true;
        leaf.visible = true;
    } else {
        if (node.parent.children) {
            // We need to collapse the path, so children should be erased from
            // parent
            let index = node.parent.children.indexOf(node);
            if (index != -1) node.parent.children.splice(index, 1);
            if (node.parent.children.length == 0) node.parent.children = null;
        }
        collapseLeafPath(node.parent, leaf, ancestor);
    }
}

/*
    Function that collapses all the subtree of a given node
*/
function collapse(node) {
    if (node.children) { // Expanded
        node.children.forEach(item => {
            item.visible = false;
            collapse(item);
        });
        node.children = null;
    }
    if (!node._children) { // Leaf
        // Reset normal state of the tree
        node.parent = node.realParent;
        node.depth = node.realDepth;
        node.collapsed = false;
    }
}

/*
    Function that expands the complete tree
*/
function expandAll(node) {
    node.visible = true;
    if (node._children) {
        // Add items only if they are not cut or they are faded
        node._children.forEach(item => {
            if (!item.cut || item.faded)
                (node.children = node.children || []).push(item);
        })
        if (node.children) node.children.forEach(expandAll);
    } else {
        node.collapsed = false;
        node.depth = node.realDepth;
        node.parent = node.realParent;
    }
    return true;
}

/* 
    Function that shows next path of the given subtree. Returns true if
    there is a path that has been shown, and false otherwise
*/
function showPath(d) {
    // Leaf should be discarded
    if (!d._children) return false;
    let leaf;
    while (1) {
        leaf = findFirstNotVisibleLeaf(d);
        if (leaf) {
            if (leaf.collapsed && leaf.realDepth == leaf.depth) {
                leaf.collapsed = false;
                continue;
                // Collapsed leaves that are correctly positioned should
                // not be taken into account
            }
        }
        break;
    }
    if (leaf) {
        let ancestor;
        if (leaf.collapsed) {
            leaf.collapsed = false;
            leaf.visible = false;
            ancestor = leaf.parent;
            // Index is important to avoid shifting positions on parent
            let index = leaf.parent.children.indexOf(leaf);
            leaf.parent = leaf.realParent;
            leaf.depth = leaf.realDepth;

            expandPath(leaf, ancestor, true, index);
        } else {
            ancestor = findVisibleAncestor(leaf, d);
            expandPath(leaf, ancestor, false);
        }
        update(ancestor);
        centerNode(ancestor);
        return true;
    }
    return false;
}

/*
    Function that hides the last path of the given subtree. Returns
    true if there is a path that has been hidden, and false otherwise
*/
function hidePath(d) {
    if (!d._children) return false;
    let leaf = findLastVisibleLeaf(d);
    // Leaf that has been found
    if (leaf) {
        let ancestor = findFirstBifurcation(leaf, d);
        makeInvisible(leaf, ancestor);
        // All the nodes need to be hidden at the position of ancestor
        update(ancestor);
        centerNode(ancestor);
        return true;
    }
    return false;
}

/*
    Function that hides the first path (leftmost) and collapses it in
    the leaf
*/
function collapsePathToLeaf(d) {
    if (d._children) { // Not leaf
        let leaf, ancestor;
        do {
            leaf = findFirstNonCollapsedPathToLeaf(d);
            if (leaf) {
                ancestor = findFirstBifurcation(leaf, d);
                collapseLeafPath(leaf, leaf, ancestor);
                if (leaf.realParent !== ancestor) {
                    update(ancestor);
                    centerNode(ancestor);
                }
            }
        } while (leaf && leaf.realParent === ancestor)
    }
}

/*
    Function that handles the normal behaviour when clicking over a node
*/
function toggle(d) {
    // It is possible that d has half nodes displayed and half hidden. Consider
    // them as expanded
    if (d.children) // Node expanded -> Collapse
        collapse(d);
    else if (d._children) { // Node collapsed -> Expand
        // Add items only if they are not cut or they are faded
        d._children && d._children.forEach(item => {
            if (!item.cut || item.faded) {
                (d.children = d.children || []).push(item);
                item.visible = true;
            }
        })
    }
    update(d);
    centerNode(d);
}

/*
    Function that applies func to node d. It is used to show or hide 
    all the nodes but with a transition (not all at one time)
*/
function pathDelayed(d, func) {
    return new Promise(resolve => {
        setTimeout(() => {
            resolve(func(d))
        }, TRANSITION_DURATION);
    });
}

/*
    Function that applies func to node d while its possible (that
    is, the function applied to d returns false), but with a given delay
*/
async function allPaths(d, func) {
    const path = await pathDelayed(d, func);
    if (path) allPaths(d, func);
}